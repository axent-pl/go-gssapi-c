package gssapi

import (
	"fmt"
	"io"
	"os"
	"testing"

	g "github.com/golang-auth/go-gssapi/v3"
	"github.com/stretchr/testify/assert"
)

func TestImportName(t *testing.T) {
	assert := NewAssert(t)

	lib := New()

	name, err := lib.ImportName("fooname", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer releaseName(name)

	name, err = lib.ImportName("fooname", g.GSS_NT_HOSTBASED_SERVICE)
	assert.NoError(err)
	defer releaseName(name)

	// and a "bad" name
	_, err = lib.ImportName("", g.GSS_NT_USER_NAME)
	assert.ErrorIs(err, g.ErrBadName)
}

func TestCompareName(t *testing.T) {
	assert := assert.New(t)

	lib := New()

	name1, err := lib.ImportName("fooname", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer releaseName(name1)

	name2, err := lib.ImportName("fooname", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer releaseName(name2)

	name3, err := lib.ImportName("barname", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer releaseName(name3)

	name4, err := lib.ImportName("fooname", g.GSS_NT_HOSTBASED_SERVICE)
	assert.NoError(err)
	defer releaseName(name4)

	equal, err := name1.Compare(name1)
	assert.NoError(err)
	assert.True(equal)

	equal, err = name1.Compare(name2)
	assert.NoError(err)
	assert.True(equal)

	equal, err = name1.Compare(name3)
	assert.NoError(err)
	assert.False(equal)

	equal, err = name1.Compare(name4)
	assert.NoError(err)
	assert.False(equal)

}

func TestDisplayName(t *testing.T) {
	assert := NewAssert(t)

	lib := New()

	name1, err := lib.ImportName("fooname", g.GSS_NT_USER_NAME)
	assert.NoErrorFatal(err)
	defer releaseName(name1)

	displayName, nameType, err := name1.Display()
	assert.NoError(err)
	assert.Equal("fooname", displayName)
	assert.Equal(g.GSS_NT_USER_NAME, nameType)

	// The value passed to gss_display_name will be null..
	name2 := GssName{}
	_, _, err = name2.Display()
	if !IsHeimdal() {
		assert.ErrorIs(err, ErrInaccessibleRead)
	}
	assert.ErrorIs(err, g.ErrBadName)
}

func TestInquireMechsForName(t *testing.T) {
	lib := New()

	type testInfo struct {
		name            string
		nameType        g.GssNameType
		expectError     bool
		expectMechCount int
	}

	var tests []testInfo
	if IsHeimdal() {
		tests = []testInfo{
			{"foo", g.GSS_NT_HOSTBASED_SERVICE, false, 2},
			{"foo@bar.com", g.GSS_KRB5_NT_PRINCIPAL_NAME, false, 1},
		}
	} else {
		tests = []testInfo{
			{"", g.GSS_NT_ANONYMOUS, false, 0},
			{"foo", g.GSS_NT_HOSTBASED_SERVICE, false, 3},
			{"foo@bar.com", g.GSS_KRB5_NT_ENTERPRISE_NAME, false, 0},
			{"foo@bar.com", g.GSS_KRB5_NT_PRINCIPAL_NAME, false, 2},
		}
	}
	for _, tt := range tests {
		name := fmt.Sprintf("%s:%s", tt.nameType.String(), tt.name)
		t.Run(name, func(t *testing.T) {
			assert := NewAssert(t)

			gssName, err := lib.ImportName(tt.name, tt.nameType)
			assert.NoErrorFatal(err)
			defer releaseName(gssName)

			mechs, err := gssName.InquireMechs()
			assert.Equal(tt.expectError, err != nil)
			if !tt.expectError {
				assert.Equal(len(mechs), tt.expectMechCount)
			}
		})
	}

}

// default realm defined
var krb5Conf1 = `
[libdefaults]

dns_lookup_realm = false
default_realm = FOO.COM
`

// missing default realm
var krb5Conf2 = `
[libdefaults]

dns_lookup_realm = false
`

func writeKrb5Confs() (f1, f2 string, err error) {
	fh, err := os.CreateTemp("", "test")
	if err != nil {
		return
	}

	f1 = fh.Name()
	io.WriteString(fh, krb5Conf1)
	fh.Close()

	fh, err = os.CreateTemp("", "test")
	if err != nil {
		return
	}

	f2 = fh.Name()
	io.WriteString(fh, krb5Conf2)
	fh.Close()

	return
}

func TestCanonicalizeName(t *testing.T) {
	assert := NewAssert(t)

	vars := newSaveVars("KRB5_CONFIG")
	defer vars.Restore()

	lib := New()

	f1, f2, err := writeKrb5Confs()
	assert.NoErrorFatal(err)
	defer os.Remove(f1)
	defer os.Remove(f2)

	name1, err := lib.ImportName("foo", g.GSS_NT_USER_NAME)
	assert.NoErrorFatal(err)
	defer releaseName(name1)

	// test with a config that allows the Kerberos to find the realm
	os.Setenv("KRB5_CONFIG", f1)
	cName1, err := name1.Canonicalize(g.GSS_MECH_KRB5)
	assert.NoError(err)
	defer releaseName(cName1)

	// test with a config that has no default realm, so this should fail to canonicalize
	// on MIT (but NOT on Heimdal which uses krb5_get_host_realm(local hostname))
	if !IsHeimdal() {
		os.Setenv("KRB5_CONFIG", f2)
		_, err := name1.Canonicalize(g.GSS_MECH_KRB5)

		assert.Error(err)
		if err != nil {
			assert.Contains(err.Error(), "does not specify default realm")
		}
	}
}

func TestExportName(t *testing.T) {
	assert := NewAssert(t)

	vars := newSaveVars("KRB5_CONFIG")
	defer vars.Restore()

	lib := New()

	f1, f2, err := writeKrb5Confs()
	assert.NoError(err)
	defer os.Remove(f1)
	defer os.Remove(f2)
	os.Setenv("KRB5_CONFIG", f1)

	name1, err := lib.ImportName("fooname", g.GSS_NT_USER_NAME)
	assert.NoErrorFatal(err)
	defer name1.Release()

	// should error as name1 was not generated by gss_accept_sec_context or gss_canonicalize_name
	// (except for Heimdal - why?..)
	if !IsHeimdal() {
		_, err := name1.Export()
		assert.ErrorIs(err, g.ErrNameNotMn)
	}

	// now canonicalize amd try again
	cName1, err := name1.Canonicalize(g.GSS_MECH_KRB5)
	assert.NoErrorFatal(err)
	exp, err := cName1.Export()
	assert.NoError(err)
	if err != nil {
		assert.NotEmpty(exp)
	}
}

func TestDuplicateName(t *testing.T) {
	assert := assert.New(t)
	lib := New()

	name1, err := lib.ImportName("fooname", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer name1.Release()

	name2, err := name1.Duplicate()
	assert.NoError(err)
	defer name2.Release()

	equal, err := name1.Compare(name2)
	assert.NoError(err)
	assert.True(equal)

	equal, err = name2.Compare(name1)
	assert.NoError(err)
	assert.True(equal)

}
