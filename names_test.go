package gssapi

import (
	"fmt"
	"io"
	"os"
	"testing"

	g "github.com/golang-auth/go-gssapi/v3"
	"github.com/stretchr/testify/assert"
)

func TestImportName(t *testing.T) {
	assert := assert.New(t)

	lib := New()

	name, err := lib.ImportName("fooname", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer name.Release()

	name, err = lib.ImportName("fooname", g.GSS_NT_MACHINE_UID_NAME)
	assert.NoError(err)
	defer name.Release()

	// and a "bad" name
	_, err = lib.ImportName("", g.GSS_NT_USER_NAME)
	assert.ErrorIs(err, g.ErrBadName)
}

func TestCompareName(t *testing.T) {
	assert := assert.New(t)

	lib := New()

	name1, err := lib.ImportName("fooname", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer name1.Release()

	name2, err := lib.ImportName("fooname", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer name2.Release()

	name3, err := lib.ImportName("barname", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer name3.Release()

	name4, err := lib.ImportName("fooname", g.GSS_NT_HOSTBASED_SERVICE)
	assert.NoError(err)
	defer name4.Release()

	equal, err := name1.Compare(name1)
	assert.NoError(err)
	assert.True(equal)

	equal, err = name1.Compare(name2)
	assert.NoError(err)
	assert.True(equal)

	equal, err = name1.Compare(name3)
	assert.NoError(err)
	assert.False(equal)

	equal, err = name1.Compare(name4)
	assert.NoError(err)
	assert.False(equal)

}

func TestDisplayName(t *testing.T) {
	assert := assert.New(t)

	lib := New()

	name1, err := lib.ImportName("fooname", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer name1.Release()

	displayName, nameType, err := name1.Display()
	assert.NoError(err)
	assert.Equal("fooname", displayName)
	assert.Equal(g.GSS_NT_USER_NAME, nameType)

	// The value passed to gss_display_name will be null..
	name2 := GssName{}
	_, _, err = name2.Display()
	assert.ErrorIs(err, ErrInaccessibleRead)
	assert.ErrorIs(err, g.ErrBadName)
}

func TestInquireMechsForName(t *testing.T) {
	assert := assert.New(t)

	lib := New()

	tests := []struct {
		name            string
		nameType        g.GssNameType
		expectError     bool
		expectMechCount int
	}{
		{"", g.GSS_NT_ANONYMOUS, false, 0}, // None of the MIT mechs support anonymous
		{"foo", g.GSS_NT_HOSTBASED_SERVICE, false, 3},
		{"foo@bar.com", g.GSS_KRB5_NT_ENTERPRISE_NAME, false, 0},
		{"foo@bar.com", g.GSS_KRB5_NT_PRINCIPAL_NAME, false, 2},
	}

	for _, tt := range tests {
		name := fmt.Sprintf("%s:%s", tt.nameType.String(), tt.name)
		t.Run(name, func(t *testing.T) {
			gssName, err := lib.ImportName(tt.name, tt.nameType)
			assert.NoError(err)
			defer gssName.Release()

			mechs, err := gssName.InquireMechs()
			assert.Equal(tt.expectError, err != nil)
			if !tt.expectError {
				assert.Equal(tt.expectMechCount, len(mechs))
			}
		})
	}

}

// default realm defined
var krb5Conf1 = `
[libdefaults]

dns_lookup_realm = false
default_realm = FOO.COM
`

// missing default realm
var krb5Conf2 = `
[libdefaults]

dns_lookup_realm = false
`

func writeKrb5Confs() (f1, f2 string, err error) {
	fh, err := os.CreateTemp("", "test")
	if err != nil {
		return
	}

	f1 = fh.Name()
	io.WriteString(fh, krb5Conf1)
	fh.Close()

	fh, err = os.CreateTemp("", "test")
	if err != nil {
		return
	}

	f2 = fh.Name()
	io.WriteString(fh, krb5Conf2)
	fh.Close()

	return
}

func TestCanonicalizeName(t *testing.T) {
	assert := assert.New(t)
	vars := newSaveVars("KRB5_CONFIG")
	defer vars.Restore()

	lib := New()

	f1, f2, err := writeKrb5Confs()
	assert.NoError(err)
	defer os.Remove(f1)
	defer os.Remove(f2)

	name1, err := lib.ImportName("foo", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer name1.Release()

	// test with a config that allows the Kerberos to find the realm
	os.Setenv("KRB5_CONFIG", f1)
	cName1, err := name1.Canonicalize(g.GSS_MECH_KRB5)
	assert.NoError(err)
	defer cName1.Release()

	// test with a config that has no default realm, so this should fail to canonicalize
	os.Setenv("KRB5_CONFIG", f2)
	_, err = name1.Canonicalize(g.GSS_MECH_KRB5)
	assert.Error(err)
	assert.Contains(err.Error(), "does not specify default realm")
}

func TestExportName(t *testing.T) {
	assert := assert.New(t)
	vars := newSaveVars("KRB5_CONFIG")
	defer vars.Restore()

	lib := New()

	f1, f2, err := writeKrb5Confs()
	assert.NoError(err)
	defer os.Remove(f1)
	defer os.Remove(f2)
	os.Setenv("KRB5_CONFIG", f1)

	name1, err := lib.ImportName("fooname", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer name1.Release()

	// should error as name1 was not generated by gss_accept_sec_context or gss_canonicalize_name
	_, err = name1.Export()
	assert.ErrorIs(err, g.ErrNameNotMn)

	// now canonicalize amd try again
	cName1, err := name1.Canonicalize(g.GSS_MECH_KRB5)
	assert.NoError(err)
	exp, err := cName1.Export()
	assert.NoError(err)
	assert.NotEmpty(exp)

}

func TestDuplicateName(t *testing.T) {
	assert := assert.New(t)
	lib := New()

	name1, err := lib.ImportName("fooname", g.GSS_NT_USER_NAME)
	assert.NoError(err)
	defer name1.Release()

	name2, err := name1.Duplicate()
	assert.NoError(err)
	defer name2.Release()

	equal, err := name1.Compare(name2)
	assert.NoError(err)
	assert.True(equal)

	equal, err = name2.Compare(name1)
	assert.NoError(err)
	assert.True(equal)

}
